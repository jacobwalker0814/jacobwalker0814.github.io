<!DOCTYPE html>
<html lang="en-us">

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta name="generator" content="Hugo 0.76.5" />


<link rel="canonical" url="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html" />










<link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/readable/bootstrap.min.css" rel="stylesheet" integrity="sha384-Li5uVfY2bSkD3WQyiHX8tJd0aMF91rMrQP5aAewFkHkVSTT2TmD2PehZeMmm7aiL" crossorigin="anonymous">


<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" crossorigin="anonymous">



<link href="https://cdnjs.cloudflare.com/ajax/libs/devicons/1.8.0/css/devicons.min.css" rel="stylesheet" crossorigin="anonymous">



<link rel="stylesheet" href="/css/highlight.js/vs.css">


<link rel="stylesheet" href="/css/main.css" >


<link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/images/icons/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="/images/icons/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/images/icons/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/images/icons/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">

<meta property="og:title" content="Concurrency Trap #2: Incomplete Work" />
<meta property="og:description" content="One of the traps of concurrency is &#34;incomplete work&#34; which occurs when a program terminates before outstanding Goroutines complete. Depending on the program, this may be a serious problem. This post demonstrates the trap and discusses possible solutions." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://jacob-walker.com/blog/2019/04/concurrency-trap-2-incomplete-work.html" />
<meta property="og:type" content="article" />

<meta property="og:image" content="https://www.gravatar.com/avatar/0ee0ed1d5c1b450c2c76651dd62f38c4.png?s=300" />

<title>Concurrency Trap #2: Incomplete Work &middot; jcbwlkr</title>
</head>


<body>
  <div class="container">
  <div class="navbar navbar-default navbar-static-top">
    <div class="container">
      <div class="navbar-header">
        <a href="/" class="navbar-brand">jcbwlkr</a>
        <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <div class="navbar-collapse navbar-right collapse" id="navbar-main">
        <ul class="nav navbar-nav">
          
          <li
            class="active"
            
          >
            <a href="/blog.html"><i class='fa fa-book'></i> Blog</a>
          </li>
          
          <li
            
            
          >
            <a href="/portfolio.html"><i class='fa fa-briefcase'></i> Portfolio</a>
          </li>
          
          <li
            
            
          >
            <a href="/resume/jacob_walker_resume.pdf"><i class='fa fa-file'></i> Resume</a>
          </li>
          
        </ul>
      </div>
    </div>
  </div>
</div>


  <div class="container">
    <article>
      <header>
        <h1>Concurrency Trap #2: Incomplete Work</h1>
        <div class="post-meta">
  
  <div>
    
      <i class="fa fa-calendar fa-fw"></i>
      <time>2019-04-18</time>
    

    
      
      
        <i class="fa fa-folder fa-fw"></i>
        
          <a href="https://jacob-walker.com/categories/go.html" alt="go">go</a>
          
        
      
    

    
      
      
        <i class="fa fa-tags fa-fw"></i>
        
          <a href="https://jacob-walker.com/tags/concurrency.html">concurrency</a>
        
      
    
  </div>
</div>

      </header>

      <p>This post was originally published on the <a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html">Ardan Labs Blog</a>.</p>
<h3 id="introduction">Introduction</h3>
<p>In my first post on <a href="https://jacob-walker.com/blog/goroutine-leaks-the-forgotten-sender.html">Goroutine Leaks</a>, I mentioned that concurrency is a useful tool but it comes with certain traps that don&rsquo;t exist in synchronous programs. To continue with this theme, I will introduce a new trap called incomplete work. Incomplete work occurs when a program terminates before outstanding Goroutines (non-main goroutines) complete. Depending on the nature of the Goroutine that is being terminated forcefully, this may be a serious problem.</p>
<h3 id="incomplete-work">Incomplete Work</h3>
<p>To see a simple example of incomplete work, examine this program.</p>
<p><strong>Listing 1</strong><br>
<a href="https://play.golang.org/p/VORJoAD2oAh">https://play.golang.org/p/VORJoAD2oAh</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">5</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
<span style="color:#ae81ff">6</span>     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello&#34;</span>)
<span style="color:#ae81ff">7</span>     <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Goodbye&#34;</span>)
<span style="color:#ae81ff">8</span> }
</code></pre></div><p>The program in Listing 1 prints <code>&quot;Hello&quot;</code> on line 6 and then on line 7, the program calls <code>fmt.Println</code> again but does so within the scope of a different Goroutine. Immediately after scheduling this new Goroutine, the program reaches the end of the <code>main</code> function and terminates. If you run this program you won&rsquo;t see the &ldquo;Goodbye&rdquo; message because in the <a href="https://golang.org/ref/spec#Program_execution">Go specification</a> there is a rule:</p>
<blockquote>
<p><em>&ldquo;Program execution begins by initializing the main package and then invoking the function <code>main</code>. When that function invocation returns, the program exits. It does not wait for other (non-main) goroutines to complete.&quot;</em></p>
</blockquote>
<p>The spec is clear that your program will not wait for any outstanding Goroutines to finish when the program returns from the <code>main</code> function. This is a good thing! Consider how easy it is to let a Goroutine leak or have a Goroutine run for a very long time. If your program waited for non-main Goroutines to finish before it could be terminated, it could be stuck in some kind of zombie state and never terminate.</p>
<p>However, this termination behavior becomes a problem when you start a Goroutine to do something important, but the <code>main</code> function does not know to wait for it to complete. This type of scenario can lead to integrity issues such as corrupting databases, file systems, or losing data.</p>
<h3 id="a-real-example">A Real Example</h3>
<p>At Ardan Labs, my team built a web service for a client that required certain events to be tracked. The system for recording events had a method similar to the type <code>Tracker</code> shown below in Listing 2:</p>
<p><strong>Listing 2</strong><br>
<a href="https://play.golang.org/p/8LoUoCdrT7T">https://play.golang.org/p/8LoUoCdrT7T</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"> <span style="color:#ae81ff">9</span> <span style="color:#75715e">// Tracker knows how to track events for the application.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">10</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Tracker</span> <span style="color:#66d9ef">struct</span>{}
<span style="color:#ae81ff">11</span> 
<span style="color:#ae81ff">12</span> <span style="color:#75715e">// Event records an event to a database or stream.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">13</span> <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tracker</span>) <span style="color:#a6e22e">Event</span>(<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">string</span>) {
<span style="color:#ae81ff">14</span>     <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>) <span style="color:#75715e">// Simulate network write latency.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">15</span>     <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">data</span>)
<span style="color:#ae81ff">16</span> }
</code></pre></div><p>The client was concerned that tracking these events would add unnecessary latency to response times and wanted to perform the tracking asynchronously. <strong>It is unwise to make assumptions about performance</strong>, so our first task was to measure latency of the service with events tracked in a straight-forward and synchronous approach. In this case, the latency was unacceptably high and the team decided an asynchronous approach was needed. If the synchronous approach was fast enough then this story would be over as we would have moved on to more important things.</p>
<p>With that in mind, the handlers that tracked events were initially written like this:</p>
<p><strong>Listing 3</strong><br>
<a href="https://play.golang.org/p/8LoUoCdrT7T">https://play.golang.org/p/8LoUoCdrT7T</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">18</span> <span style="color:#75715e">// App holds application state.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">19</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">App</span> <span style="color:#66d9ef">struct</span> {
<span style="color:#ae81ff">20</span>     <span style="color:#a6e22e">track</span> <span style="color:#a6e22e">Tracker</span>
<span style="color:#ae81ff">21</span> }
<span style="color:#ae81ff">22</span> 
<span style="color:#ae81ff">23</span> <span style="color:#75715e">// Handle represents an example handler for the web service.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">24</span> <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">App</span>) <span style="color:#a6e22e">Handle</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
<span style="color:#ae81ff">25</span> 
<span style="color:#ae81ff">26</span>     <span style="color:#75715e">// Do some actual work.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">27</span> 
<span style="color:#ae81ff">28</span>     <span style="color:#75715e">// Respond to the client.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">29</span>     <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">WriteHeader</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusCreated</span>)
<span style="color:#ae81ff">30</span> 
<span style="color:#ae81ff">31</span>     <span style="color:#75715e">// Fire and Hope.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">32</span>     <span style="color:#75715e">// BUG: We are not managing this goroutine.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">33</span>     <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">track</span>.<span style="color:#a6e22e">Event</span>(<span style="color:#e6db74">&#34;this event&#34;</span>)
<span style="color:#ae81ff">34</span> }
</code></pre></div><p>The significant part of the code in listing 3 is line 33. This is where the <code>a.track.Event</code> method is being called within the scope of a new Goroutine. This had the desired effect of tracking events asynchronously without adding latency to the request. However, this code falls into the <em>incomplete work</em> trap and must be refactored. Any Goroutine created on line 33 has no guarantee of running or finishing. This is an integrity issue as events can be lost when the server shuts down.</p>
<h3 id="refactor-for-guarantees">Refactor For Guarantees</h3>
<p>To avoid the trap, the team modified the <code>Tracker</code> type to manage the Goroutines itself. The type uses a <code>sync.WaitGroup</code> to keep a count of open Goroutines and provides a <code>Shutdown</code> method for the <code>main</code> function to call which waits until all Goroutines have finished.</p>
<p>First the handlers were modified to not create Goroutines directly. The only change in Listing 4 is line 53 which no longer includes the <code>go</code> keyword.</p>
<p><strong>Listing 4</strong><br>
<a href="https://play.golang.org/p/BMah6_C57-l">https://play.golang.org/p/BMah6_C57-l</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">44</span> <span style="color:#75715e">// Handle represents an example handler for the web service.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">45</span> <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">App</span>) <span style="color:#a6e22e">Handle</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
<span style="color:#ae81ff">46</span> 
<span style="color:#ae81ff">47</span>     <span style="color:#75715e">// Do some actual work.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">48</span> 
<span style="color:#ae81ff">49</span>     <span style="color:#75715e">// Respond to the client.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">50</span>     <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">WriteHeader</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">StatusCreated</span>)
<span style="color:#ae81ff">51</span> 
<span style="color:#ae81ff">52</span>     <span style="color:#75715e">// Track the event.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">53</span>     <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">track</span>.<span style="color:#a6e22e">Event</span>(<span style="color:#e6db74">&#34;this event&#34;</span>)
<span style="color:#ae81ff">54</span> }
</code></pre></div><p>Next the <code>Tracker</code> type was rewritten to manage Goroutines itself.</p>
<p><strong>Listing 5</strong><br>
<a href="https://play.golang.org/p/BMah6_C57-l">https://play.golang.org/p/BMah6_C57-l</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">10</span> <span style="color:#75715e">// Tracker knows how to track events for the application.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">11</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Tracker</span> <span style="color:#66d9ef">struct</span> {
<span style="color:#ae81ff">12</span>     <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
<span style="color:#ae81ff">13</span> }
<span style="color:#ae81ff">14</span> 
<span style="color:#ae81ff">15</span> <span style="color:#75715e">// Event starts tracking an event. It runs asynchronously to
</span><span style="color:#75715e"></span><span style="color:#ae81ff">16</span> <span style="color:#75715e">// not block the caller. Be sure to call the Shutdown function
</span><span style="color:#75715e"></span><span style="color:#ae81ff">17</span> <span style="color:#75715e">// before the program exits so all tracked events finish.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">18</span> <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tracker</span>) <span style="color:#a6e22e">Event</span>(<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">string</span>) {
<span style="color:#ae81ff">19</span> 
<span style="color:#ae81ff">20</span>     <span style="color:#75715e">// Increment counter so Shutdown knows to wait for this event.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">21</span>     <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
<span style="color:#ae81ff">22</span> 
<span style="color:#ae81ff">23</span>     <span style="color:#75715e">// Track event in a goroutine so caller is not blocked.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">24</span>     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
<span style="color:#ae81ff">25</span> 
<span style="color:#ae81ff">26</span>         <span style="color:#75715e">// Decrement counter to tell Shutdown this goroutine finished.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">27</span>         <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
<span style="color:#ae81ff">28</span> 
<span style="color:#ae81ff">29</span>         <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>) <span style="color:#75715e">// Simulate network write latency.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">30</span>         <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">data</span>)
<span style="color:#ae81ff">31</span>     }()
<span style="color:#ae81ff">32</span> }
<span style="color:#ae81ff">33</span> 
<span style="color:#ae81ff">34</span> <span style="color:#75715e">// Shutdown waits for all tracked events to finish processing.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">35</span> <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tracker</span>) <span style="color:#a6e22e">Shutdown</span>() {
<span style="color:#ae81ff">36</span>     <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
<span style="color:#ae81ff">37</span> }
</code></pre></div><p>In listing 5, line 12 adds a <code>sync.WaitGroup</code> to the type definition of <code>Tracker</code>. Inside the <code>Event</code> method on line 21, <code>t.wg.Add(1)</code> is called. This increments the counter to account for the Goroutine that is created on line 24. As soon as that Goroutine is created, the <code>Event</code> function returns which is what satisfies the client&rsquo;s requirement of minimizing event tracking latency. The Goroutine that is created does its work and when it&rsquo;s done it calls <code>t.wg.Done()</code> on line 27. Calling the <code>Done</code> method decrements the counter so the WaitGroup knows this Goroutine has finished.</p>
<p>The calls to <code>Add</code> and <code>Done</code> are useful for tracking the number of active Goroutines but the program must still be instructed to wait for them to finish. To allow this, the <code>Tracker</code> type gains a new method <code>Shutdown</code> on line 35. The simplest implementation of this function is to call <code>t.wg.Wait()</code>, which blocks until the Goroutine count is reduced to 0. Finally this method must be called from <code>func main</code> as in listing 6:</p>
<p><strong>Listing 6</strong><br>
<a href="https://play.golang.org/p/BMah6_C57-l">https://play.golang.org/p/BMah6_C57-l</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">56</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
<span style="color:#ae81ff">57</span> 
<span style="color:#ae81ff">58</span>     <span style="color:#75715e">// Start a server.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">59</span>     <span style="color:#75715e">// Details not shown...
</span><span style="color:#75715e"></span><span style="color:#ae81ff">60</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">App</span>
<span style="color:#ae81ff">61</span> 
<span style="color:#ae81ff">62</span>     <span style="color:#75715e">// Shut the server down.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">63</span>     <span style="color:#75715e">// Details not shown...
</span><span style="color:#75715e"></span><span style="color:#ae81ff">64</span> 
<span style="color:#ae81ff">65</span>     <span style="color:#75715e">// Wait for all event goroutines to finish.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">66</span>     <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">track</span>.<span style="color:#a6e22e">Shutdown</span>()
<span style="color:#ae81ff">67</span> }
</code></pre></div><p>The important part of listing 6 is line 66 which blocks <code>func main</code> from terminating until <code>a.track.Shutdown()</code> finishes.</p>
<h3 id="but-maybe-dont-wait-too-long">But maybe don&rsquo;t wait too long</h3>
<p>The implementation shown for the <code>Shutdown</code> method is simple and does the job needed; it waits for the Goroutines to finish. Unfortunately, there is no limit on how long it will wait. Depending on your production environment you might not be willing to wait indefinitely for your program to shut down. To add a deadline to the <code>Shutdown</code> method, the team changed it to this:</p>
<p><strong>Listing 7</strong><br>
<a href="https://play.golang.org/p/p4gsDkpw1Gh">https://play.golang.org/p/p4gsDkpw1Gh</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">36</span> <span style="color:#75715e">// Shutdown waits for all tracked events to finish processing
</span><span style="color:#75715e"></span><span style="color:#ae81ff">37</span> <span style="color:#75715e">// or for the provided context to be canceled.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">38</span> <span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Tracker</span>) <span style="color:#a6e22e">Shutdown</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">error</span> {
<span style="color:#ae81ff">39</span> 
<span style="color:#ae81ff">40</span>     <span style="color:#75715e">// Create a channel to signal when the waitgroup is finished.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">41</span>     <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
<span style="color:#ae81ff">42</span> 
<span style="color:#ae81ff">43</span>     <span style="color:#75715e">// Create a goroutine to wait for all other goroutines to
</span><span style="color:#75715e"></span><span style="color:#ae81ff">44</span>     <span style="color:#75715e">// be done then close the channel to unblock the select.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">45</span>     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
<span style="color:#ae81ff">46</span>         <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
<span style="color:#ae81ff">47</span>         close(<span style="color:#a6e22e">ch</span>)
<span style="color:#ae81ff">48</span>     }()
<span style="color:#ae81ff">49</span> 
<span style="color:#ae81ff">50</span>     <span style="color:#75715e">// Block this function from returning. Wait for either the
</span><span style="color:#75715e"></span><span style="color:#ae81ff">51</span>     <span style="color:#75715e">// waitgroup to finish or the context to expire.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">52</span>     <span style="color:#66d9ef">select</span> {
<span style="color:#ae81ff">53</span>     <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
<span style="color:#ae81ff">54</span>         <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
<span style="color:#ae81ff">55</span>     <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>():
<span style="color:#ae81ff">56</span>         <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;timeout&#34;</span>)
<span style="color:#ae81ff">57</span>     }
<span style="color:#ae81ff">58</span> }
</code></pre></div><p>Now in Listing 7 on line 38 the <code>Shutdown</code> method takes a <code>context.Context</code> as input. This is how the caller will limit the time that <code>Shutdown</code> is allowed to wait. In the function on line 41, a channel is created and then on line 45 a Goroutine is launched. This new Goroutine&rsquo;s only job is to wait for the WaitGroup to finish and then close the channel. Finally line 52 starts a <code>select</code> block which waits for either the context to be canceled or the channel to be closed.</p>
<p>Next the team changed the call in <code>func main</code> to this:</p>
<p><strong>Listing 8</strong><br>
<a href="https://play.golang.org/p/p4gsDkpw1Gh">https://play.golang.org/p/p4gsDkpw1Gh</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">86</span>     <span style="color:#75715e">// Wait up to 5 seconds for all event goroutines to finish.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">87</span>     <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">timeout</span> = <span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>
<span style="color:#ae81ff">88</span>     <span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithTimeout</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#a6e22e">timeout</span>)
<span style="color:#ae81ff">89</span>     <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cancel</span>()
<span style="color:#ae81ff">90</span> 
<span style="color:#ae81ff">91</span>     <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">track</span>.<span style="color:#a6e22e">Shutdown</span>(<span style="color:#a6e22e">ctx</span>)
</code></pre></div><p>In listing 8 a context is created in the <code>main</code> function with a 5 second timeout. This is passed to <code>a.track.Shutdown</code> to set the limit on how long <code>main</code> is willing to wait.</p>
<h3 id="conclusion">Conclusion</h3>
<p>With the introduction of Goroutines, the handlers for this server were able to minimize the latency cost for API clients that needed to track events. It would have been easy to just use the <code>go</code> keyword to run this work in the background but that solution has integrity issues. Doing this properly requires putting in the effort to ensure all relevant Goroutines have terminated before letting the program shut down.</p>
<p><em><strong>Concurrency is a useful tool, but it must be used with caution.</strong></em></p>


      
<hr />
<div class="row">
  <div class="col-md-6 text-left">
    
    <nav class="prev">
      <a href="https://jacob-walker.com/blog/goroutine-leaks-the-abandoned-receivers.html"><i class="fa fa-fw fa-chevron-left"></i> Goroutine Leaks - The Abandoned Receivers</a>
    </nav>
    
  </div>
  <div class="col-md-6 text-right">
    
  </div>
</div>


    </article>

    
<div id="disqus_thread"></div>

<script type="text/javascript">
(function() {
  
  
  if (window.location.hostname == "localhost") {
    return;
  }

  var hr = document.createElement('hr');
  var t = document.getElementById('disqus_thread');
  t.parentNode.insertBefore(hr, t);

  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  var disqus_shortname = 'jacobwalker0814';
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  </div>

  <div class="container">
  <hr>
  <footer>
    <p class="pull-left">&copy; Jacob Walker 2019</p>
    <p class="pull-right">
      <a href="https://twitter.com/jcbwlkr" class="fa-stack" title="Jacob Walker on Twitter">
        <i class="fa fa-square-o fa-stack-2x" aria-hidden="true"></i>
        <i class="fa fa-twitter fa-stack-1x" aria-hidden="true"></i>
      </a>
      <a href="https://github.com/jcbwlkr" class="fa-stack" title="Jacob Walker on Github">
        <i class="fa fa-square-o fa-stack-2x" aria-hidden="true"></i>
        <i class="fa fa-github fa-stack-1x" aria-hidden="true"></i>
      </a>
      <a href="https://stackoverflow.com/users/859353/jcbwlkr" class="fa-stack" title="Jacob Walker on Stack Overflow">
        <i class="fa fa-square-o fa-stack-2x" aria-hidden="true"></i>
        <i class="fa fa-stack-overflow fa-stack-1x" aria-hidden="true"></i>
      </a>
      <a href="https://www.youtube.com/channel/UC5R8ji-vKH6NhUQTozKn5eg" class="fa-stack" title="Jacob Walker on YouTube">
        <i class="fa fa-square-o fa-stack-2x" aria-hidden="true"></i>
        <i class="fa fa-youtube fa-stack-1x" aria-hidden="true"></i>
      </a>
      <a href="https://www.linkedin.com/in/jcbwlkr" class="fa-stack" title="Jacob Walker on LinkedIn">
        <i class="fa fa-square-o fa-stack-2x" aria-hidden="true"></i>
        <i class="fa fa-linkedin fa-stack-1x" aria-hidden="true"></i>
      </a>
      <a href="/blog/index.xml" class="fa-stack" title="Blog RSS Feed">
        <i class="fa fa-square-o fa-stack-2x" aria-hidden="true"></i>
        <i class="fa fa-rss fa-stack-1x" aria-hidden="true"></i>
      </a>
    </p>
  </footer>
</div>


<script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<script type="text/javascript">
(function() {
  
  if (window.location.hostname == "localhost") {
    return;
  }

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42678895-1', 'auto');
  ga('send', 'pageview');
})();
</script>


</body>
</html>
